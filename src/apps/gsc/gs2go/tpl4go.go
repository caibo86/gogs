// -------------------------------------------
// @file      : tpl4go.go
// @author    : 蔡波
// @contact   : caibo923@gmail.com
// @time      : 2023/12/19 下午4:11
// -------------------------------------------

package main

var tpl4go = `
{{/**************************************************************************/}}

{{define "imports"}}
import(
	"math/bits"
    {{range $index, $element := .}} {{$index}} "{{$element.Name}}"
    {{end}}
)
{{end}}


{{/**************************************************************************/}}

{{define "script"}}


{{end}}

{{/**************************************************************************/}}

{{define "error"}}
{{$Enum := symbol .Name}}
// /////////////////////////////////////////////////////////////////////////////////////////////////////////

// {{$Enum}} is an autogenerated enum {{printComments .}} 
type {{$Enum}} int32

const (
{{range .SortedValues}}    {{$Enum}}{{symbol .Name}} {{$Enum}} = {{.Value}} {{printCommentsToLine .}}
{{end}} )

// String is an autogenerated method, implementing fmt.Stringer
func (val {{$Enum}}) String() string {
    switch val {  {{range .SortedValues}}
    case {{.Value}}:
        return "{{$Enum}}{{symbol .Name}}"{{end}}
    }
    return fmt.Sprintf("Unknown{{$Enum}}(%d)",val)
}

// Error is an autogenerated method, implementing error
func (val {{$Enum}}) Error() string {
    switch val {  {{range .SortedValues}}
    case {{.Value}}:
        return "{{$Enum}}{{symbol .Name}}"{{end}}
    }
    return fmt.Sprintf("Unknown{{$Enum}}(%d)",val)
}

{{end}}

{{/**************************************************************************/}}


{{define "enum"}}
{{$Enum := symbol .Name}}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////

// {{$Enum}} is an autogenerated enum {{printComments .}} 
type {{$Enum}} int32

const (
{{range .SortedValues}}    {{$Enum}}{{symbol .Name}} {{$Enum}} = {{.Value}}
{{end}})

// String is an autogenerated method, implementing fmt.Stringer
func (val {{$Enum}}) String() string {
    switch val {  {{range .SortedValues}}
    case {{.Value}}:
        return "{{$Enum}}{{symbol .Name}}"{{end}}
    }
    return fmt.Sprintf("Unknown{{$Enum}}(%d)", val)
}
{{end}}

{{/**************************************************************************/}}


{{define "arrayInit"}}func() {{typeName .}} {
    val := {{defaultVal .Element}}
    var buff {{typeName .}}
    for i := uint16(0); i < {{.Length}}; i ++ {
        buff[i] = val
    }
    return buff
}(){{end}}

{{/**************************************************************************/}}


{{define "struct"}}

{{$Struct := symbol .Name}}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////

{{$Receiver := lowerFirst $Struct}}


// {{$Struct}} is an autogenerated struct {{printComments .}} 
type {{$Struct}} struct { {{range .Fields}}
    {{symbol .Name}} {{typeName .Type}} {{printCommentsToLine .}} {{end}}
}

// New{{$Struct}} is an autogenerated constructor, creating a new {{$Struct}}
func New{{$Struct}}() *{{$Struct}} {
    return &{{$Struct}}{  {{range .Fields}}
        {{symbol .Name}}: {{defaultVal .Type}},     {{end}}
    }
}

// Size is an autogenerated function, returning the size of the struct
func (m *{{$Struct}})Size() int {
	if m == nil {
		return 0
	}
	n := 1
	var l int 
	_ = l
	{{range .Fields}}// {{.Name}} {{.Type.OriginName}}
	{{calTypeSize .}}
	{{end}}return n
}

// Marshal is an autogenerated function, marshalling the struct to a byte slice
func (m *{{$Struct}})Marshal() []byte {
	size := m.Size()
	data := make([]byte, size)
	m.MarshalToSizedBuffer(data[:size])
	return data
}

// MarshalTo is an autogenerated function, marshalling the struct to a byte slice
func (m *{{$Struct}})MarshalTo(data []byte) {
	size := m.Size()
	m.MarshalToSizedBuffer(data[:size])
	return
}

// MarshalToSizedBuffer is an autogenerated function, marshalling the struct to a byte slice
func (m *{{$Struct}})MarshalToSizedBuffer(data []byte) int {
	// flag
	data[0] = 0xFE
	i := 1
	{{range .Fields}}// {{.Name}} {{.Type.OriginName}}
	{{writeType .}}
	{{end}}
	return i
}

// Unmarshal is an autogenerated function, unmarshalling the struct from a byte slice
func (m *{{$Struct}})Unmarshal(data []byte) (err error) {
	defer func(){
		if e := recover(); e != nil {
			err = e.(error)
		}
	}()
	// flag
	_ = data[0]
	l := len(data)
	i := 1
	for i < l {
		var fieldID uint16
	    i, fieldID = gsnet.ReadFieldID(data, i)
		switch fieldID {
		{{range .Fields}}case {{.ID}}:
			{{readType .}}
		{{end}}}
	}
	return
}

// CopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. m must be non-nil.
func (m *{{$Struct}})CopyInto(out *{{$Struct}}) {
	*out = *m
	{{range .Fields}}{{copyType .}}
	{{end}}return
}

// Copy is an autogenerated deepcopy function, copying the receiver, creating a new {{$Struct}}.
func (m *{{$Struct}})Copy() *{{$Struct}} {
	if m == nil {
		return nil
	}
	out := new({{$Struct}})
	m.CopyInto(out)
	return out
}

// Read{{$Struct}} is an autogenerated function, reading the struct from a byte slice
func Read{{$Struct}}(data []byte, i int) (int, *{{$Struct}}, error) {
	m := New{{$Struct}}()
	var l uint32
	i, l = gsnet.ReadUint32(data, i)
	if l > uint32(len(data[i:])) {
		return i, nil, gserrors.Newf("Read{{$Struct}} err, expect %d bytes but got %d", l, len(data[i:]))
	}
	err := m.Unmarshal(data[i:i+int(l)])
	if err != nil {
		return i, nil, gserrors.Newf("Read{{$Struct}} err:%s", err.Error())
	}
	return i+int(l), m, nil
}

{{end}}

{{/**************************************************************************/}}



{{/**************************************************************************/}}


{{define "table"}}
{{$Table := symbol .Name}}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////

// {{$Table}} is an autogenerated struct
type {{$Table}} struct { 
    {{range .Fields}} {{symbol .Name}} {{typeName .Type}}
    {{end}}
}


// New{{$Table}} is an autogenerated constructor, creating a new {{$Table}}
func New{{$Table}}() *{{$Table}} {
    return &{{$Table}}{
        {{range .Fields}} {{symbol .Name}}: {{defaultVal .Type}},
        {{end}} }
}

{{end}}

{{/**************************************************************************/}}


{{define "service"}}
{{$Service := symbol .Name}}

// /////////////////////////////////////////////////////////////////////////////////////////////////////////

var rpcConfig = config.GetRPCConfig()

// {{$Service}}TypeName a unique name of the service
const {{$Service}}TypeName = "{{.Path}}"

// I{{$Service}} is an autogenerated interface
type I{{$Service}} interface {
{{range .Methods}}    {{symbol .Name}}{{params .Params}}{{returnParams .Return}}{{"\n"}}{{end}}}

//{{$Service}}Builder service builder used for building {{$Service}} service
type {{$Service}}Builder struct {
    localServiceBuilder func(service gsdock.IService) (I{{$Service}},error)
}

// New{{$Service}}Builder creating a new {{$Service}}Builder
func New{{$Service}}Builder(localServiceBuilder func(service gsdock.IService)(I{{$Service}},error)) gsdocker.ITypeBuilder {
    return &{{$Service}}Builder{
        localServiceBuilder:localServiceBuilder,
    }
}

// String implementing fmt.Stringer
func (builder *{{$Service}}Builder) String() string {
    return "{{.Path}}"
}

// NewService creating a new {{$Service}} Service
func (builder *{{$Service}}Builder) NewService(
	name string, id gsdock.ID, context interface{}) (gsdock.IService, error) {
    c := &{{$Service}}Service{
        id:id,
        name:name,
        typename:builder.String(),
        context:context,
        timeout:rpcConfig.Timeout,
    }
    var err error
    c.I{{$Service}},err = builder.localServiceBuilder(c)
    return c,err
}

// NewRemoteService creating a new {{$Service}} RemoteService
func (builder *{{$Service}}Builder) NewRemoteService(
	remote gsdock.IRemote, name string, lid gsdock.ID, 
	rid gsdock.ID, context interface{}) gsdock.IRemoteService {
    return &{{$Service}}RemoteService{
        name:name,
        remote:remote,
        context: context,
        lid :lid,
        rid :rid,
        typename :builder.String(),
        timeout:rpcConfig.Timeout,
    }
}


// {{$Service}}Service a local service inherited {{$Service}}
type {{$Service}}Service struct {
    I{{$Service}}
    id gsdock.ID
    name string
    typename string
    timeout int64
    context interface{}
}

// String implementing fmt.Stringer
func (service *{{$Service}}Service) String() string {
    return service.name
}

// Name service name
func (service *{{$Service}}Service) Name() string {
	return service.name
}

// ID service id 
func (service *{{$Service}}Service) ID() gsdock.ID {
    return service.id
}

// Type service type
func (service *{{$Service}}Service) Type() string {
    return service.typename
}

// Context service context
func (service *{{$Service}}Service) Context() interface{} {
    return service.context
}

// Call service call method
func (service *{{$Service}}Service) Call(call *gsnet.Call) (callReturn *gsnet.Return, err error) {
    defer func(){
        if e := recover(); e != nil {
            err = gserrors.New(e.(error).Error())
        }
    }()
    switch call.Method {  

		{{range .Methods}}
   		case {{.ID}}:{{$Name := symbol .Name}}
        if len(call.Params) != {{.InputParams}} {
            err = gserrors.NewfWith(gsdock.ErrRPC,"{{$Service}}::{{$Name}} expect {{.InputParams}} params but got :%d",len(call.Params))
            return
        }

		{{range .Params}}	var param{{.ID}} {{typeName .Type}}
        param{{.ID}}, _ = {{getReadFunc .Type}}(call.Params[{{.ID}}].Content, i)
       	{{end}}

		{{range .Return}}	var ret{{.ID}} {{typeName .Type}}
		{{end}}


        {{returnArgs .}} service.I{{$Service}}.{{$Name}}{{callArgs .Params}}
        if err != nil {
            return
        }
        {{if .Return}}
        callReturn = &gsnet.Return{
            ID : call.ID,
            Service:call.Service,
        }

        {{range .Return}}
        var buff{{.ID}} bytes.Buffer
        err = {{getWriteFunc .Type}}(&buff{{.ID}},ret{{.ID}})
        if err != nil {
            return
        }
        callReturn.Params = append(callReturn.Params,&gsnet.Param{Content:buff{{.ID}}.Bytes()})
        {{end}}

		{{end}}
        
		return
    
	}
    err = gserrors.NewfWith(gsdock.ErrRPC,"unknown {{$Service}}#%d method",call.Method)
    return
}


{{range .Methods}} {{$Name := symbol .Name}}
// {{$Name}} method of service {{$Service}}
func (service *{{$Service}}Service){{$Name}}{{params .Params}}{{returnParams .Return}}{
    call := &gsnet.Call{
        Service:uint16(service.id),
        Method:{{.ID}},
    }
{{range .Params}}    var param{{.ID}} bytes.Buffer
    err = {{writeType .Type}}(&param{{.ID}},arg{{.ID}})
    if err != nil {
        return
    }
    call.Params = append(call.Params,&gsnet.Param{Content:param{{.ID}}.Bytes()})
    {{end}}
    {{if .Return}}
    future := make(chan *gsnet.Return,1)
    go func(){
        var callReturn *gsnet.Return
        callReturn,err = service.Call(call)
        if err == nil {
            future <- callReturn
        }
    }()
    select {
        case callreturn := <- future:
            if len(callreturn.Params) != {{.ReturnParams}} {
                err = yferrors.Newf(yfdocker.ErrRPC,"{{$Service}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callreturn.Params))
                return
            }
            {{range .Return}}
            ret{{.ID}},err = {{readType .Type}}(bytes.NewBuffer(callreturn.Params[{{.ID}}].Content))
            if err != nil {
                err = yferrors.Newf(err,"read {{$Service}}#{{$Name}} return{{.ID}}")
                return
            }
            {{end}}
        case <- time.After(service.timeout):
            err = yfdocker.ErrTimeout
            return
    }
    {{else}}
    go func(){ service.Call(call) }()
    {{end}}
    return
}
{{end}}



// {{$Service}}RemoteService a remote service inherited gsdock.IRemote
type {{$Service}}RemoteService struct {
    remote gsdock.IRemote
    rid gsdock.ID // remote id
    lid gsdock.ID // local id
    name string
    typename string
    context interface{}
    timeout int64
}

// String implementing fmt.Stringer
func (service *{{$Service}}RemoteService) String() string {
    return service.name
}

// Name remote service name
func (service *{{$Service}}RemoteService) Name() string {
    return service.name
}

// ID remote service local id
func (service *{{$Service}}RemoteService) ID() gsdock.ID {
    return service.lid
}

// RemoteID remote service remote id
func (service *{{$Service}}RemoteService) RemoteID() gsdock.ID {
    return service.rid
}

// Remote remote service IRemote
func (service *{{$Service}}RemoteService) Remote() gsdock.IRemote {
    return service.remote
}


// Type remote service type
func (service *{{$Service}}RemoteService) Type() string {
    return service.typename
}

// Context remote service context
func (service *{{$Service}}RemoteService) Context() interface{} {
    return service.context
}

// Call remote service call
func (service *{{$Service}}RemoteService) Call(call *gsnet.Call) (callReturn *gsnet.Return, err error) {
    defer func(){
        if e := recover(); e != nil {
            err = gserrors.New(e.(error).Error())
        }
    }()
    switch call.Method {
    {{range .Methods}}
    {{$Name := .Name}}
    case {{.ID}}:
        {{if .Return}}
        var future gsdock.Future
        future,err = service.remote.Wait(service,call,service.timeout)
        if err != nil {
            err = gserrors.NewWith(err,"call {{$Service}}#{{$Name}} error")
            return
        }
        result := <-future
        if result.Timeout {
            err = gsdock.ErrTimeout
            return
        }

        callReturn =result.CallReturn

        if len(callReturn.Params) != {{.ReturnParams}} {
            err = gserrors.NewfWith(gsdock.ErrRPC,"{{$Service}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callReturn.Params))
            return
        }

        return
        {{else}}
        err = service.remote.Post(service,call)
        if err != nil {
            err = gserrors.NewWith(err,"post {{$Service}}#{{$Name}} error")
            return
        }
        return
        {{end}}
    {{end}}
    }

    err = gserrors.NewfWith(gsdock.ErrRPC,"unknown {{$Service}}#%d method",call.Method)

    return
}

{{range .Methods}}

{{$Name := symbol .Name}}

// {{$Name}} methods of remote service
func (service *{{$Service}}RemoteService){{$Name}}{{params .Params}}{{returnParams .Return}}{
    call := &gsnet.Call{
        Service:uint16(service.rid),
        Method:{{.ID}},
    }

    {{range .Params}}
    var param{{.ID}} bytes.Buffer
    err = {{writeType .Type}}(&param{{.ID}},arg{{.ID}})
    if err != nil {
        return
    }
    call.Params = append(call.Params,&gsnet.Param{Content:param{{.ID}}.Bytes()})
    {{end}}

    {{if .Return}}
    var future gsdock.Future
    future,err = service.remote.Wait(service,call,service.timeout)
    if err != nil {
        err = gsdock.NewWith(err,"call {{$Service}}#{{$Name}} error")
        return
    }
    result := <-future
    if result.Timeout {
        err = yfdocker.ErrTimeout
        return
    }

    callReturn :=result.CallReturn

    if len(callReturn.Params) != {{.ReturnParams}} {
        err = gsdock.NewfWith(gsdock.ErrRPC,"{{$Service}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callReturn.Params))
        return
    }

    {{range .Return}}


    ret{{.ID}},err = {{readType .Type}}(bytes.NewBuffer(callReturn.Params[{{.ID}}].Content))
    if err != nil {
        err = gserrors.NewWith(err,"read {{$Service}}#{{$Name}} return{{.ID}}")
        return
    }
    {{end}}
    {{else}}
    err = service.remote.Post(service,call)
    if err != nil {
        err = gserrors.NewWith(err,"post {{$Service}}#{{$Name}} error")
        return
    }
    {{end}}

    return

}
{{end}}

{{/**************************************************************************/}}

{{end}}
`
