// -------------------------------------------
// @file      : tpl4go.go
// @author    : 蔡波
// @contact   : caibo923@gmail.com
// @time      : 2023/12/19 下午4:11
// -------------------------------------------

package main

var tpl4go = `
{{/**************************************************************************/}}

{{define "imports"}}
import(
	"math/bits"
    {{range $index, $element := .}} {{$index}} "{{$element.Name}}"
    {{end}}
)
{{end}}


{{/**************************************************************************/}}

{{define "script"}}


{{end}}

{{/**************************************************************************/}}

{{define "error"}}{{$Enum := symbol .Name}}
// {{$Enum}} enum and error, generated by gsc
type {{$Enum}} int32
// 枚举 {{$Enum}} 常量 gsc自动生成
const (
{{range .Values}}    {{$Enum}}{{symbol .Name}} {{$Enum}} = {{.Value}}
    {{end}}
)

// String fmt.Stringer, generated by gsc
func (val {{$Enum}}) String() string {
    switch val {  {{range .Values}}
    case {{.Value}}:
        return "{{$Enum}}{{symbol .Name}}"{{end}}
    }
    return fmt.Sprintf("Unknown(%d)",val)
}

// Error error, generated by gsc
func (val {{$Enum}}) Error() string {
    switch val {
        {{range .Values}}case {{.Value}}:
            return "{{$Enum}}{{symbol .Name}}"
        {{end}} }
    return fmt.Sprintf("Unknown(%d)",val)
}

{{end}}

{{/**************************************************************************/}}

{{define "enum"}}{{$Enum := symbol .Name}}
// {{$Enum}} enum, generated by gsc
type {{$Enum}} int32
// 枚举 {{$Enum}} 常量 gsc自动生成
const (
{{range .Values}}    {{$Enum}}{{symbol .Name}} {{$Enum}} = {{.Value}}
{{end}})

// String fmt.Stringer, generated by gsc
func (val {{$Enum}}) String() string {
    switch val {  {{range .Values}}
    case {{.Value}}:
        return "{{$Enum}}{{symbol .Name}}"{{end}}
    }
    return fmt.Sprintf("Unknown(%d)",val)
}
{{end}}

{{/**************************************************************************/}}


{{define "arrayInit"}}func() {{typeName .}} {
    val := {{defaultVal .Element}}
    var buff {{typeName .}}
    for i := uint16(0); i < {{.Length}}; i ++ {
        buff[i] = val
    }
    return buff
}(){{end}}

{{/**************************************************************************/}}

{{define "struct"}}

{{$Struct := symbol .Name}}

{{$Receiver := lowerFirst $Struct}}

// {{$Struct}} generated by gsc
type {{$Struct}} struct { {{range .Fields}}
    {{symbol .Name}} {{typeName .Type}} {{end}}
}

// New{{$Struct}} generated by gsc
func New{{$Struct}}() *{{$Struct}} {
    return &{{$Struct}}{  {{range .Fields}}
        {{symbol .Name}}: {{defaultVal .Type}},     {{end}}
    }
}

// Size generated by gsc
func (m *{{$Struct}})Size() int {
	if m == nil {
		return 0
	}
	var n int
	var l int 
	_ = l
	{{range .Fields}}// {{.Name}} {{.Type.Name}}
	{{calTypeSize .}}
	{{end}}return n
}

// Marshal generated by gsc
func (m *{{$Struct}})Marshal() []byte {
	size := m.Size()
	data := make([]byte, size)
	m.MarshalToSizedBuffer(data[:size])
	return data
}

// MarshalTo generated by gsc
func (m *{{$Struct}})MarshalTo(data []byte) {
	size := m.Size()
	m.MarshalToSizedBuffer(data[:size])
	return
}

// MarshalToSizedBuffer generated by gsc
func (m *{{$Struct}})MarshalToSizedBuffer(data []byte) int {
	i := 0
	{{range .Fields}}// {{.Name}} {{.Type.Name}}
	{{writeType .}}
	{{end}}
	return i
}

// Unmarshal generated by gsc
func (m *{{$Struct}})Unmarshal(data []byte) (err error) {
	defer func(){
		if e := recover(); e != nil {
			err = e.(error)
		}
	}()
	l := len(data)
	i := 0
	for i < l {
		var fieldID uint16
	    i, fieldID = gsnet.ReadFieldID(data, i)
		switch fieldID {
		{{range .Fields}}case {{.ID}}:
			{{readType .}}
		{{end}}}
	}
	return
}

{{end}}

{{/**************************************************************************/}}



{{/**************************************************************************/}}

{{define "table"}}
{{$Table := symbol .Name}}

// {{$Table}} gsc自动生成
type {{$Table}} struct { 
    {{range .Fields}} {{symbol .Name}} {{typeName .Type}}
    {{end}}
}


// New{{$Table}} 用默认值生成一个结构 gsc自动生成
func New{{$Table}}() *{{$Table}} {
    return &{{$Table}}{
        {{range .Fields}} {{symbol .Name}}: {{defaultVal .Type}},
        {{end}} }
}

{{end}}

{{/**************************************************************************/}}

{{define "contract"}}   {{$Contract := symbol .Name}}

// 服务名
var (
    {{$Contract}}TypeName = "{{.Path}}"
)

// I{{$Contract}} gsc自动生成
type I{{$Contract}} interface {
{{range .Methods}}    {{symbol .Name}}{{params .Params}}{{returnParams .Return}}{{"\n"}}{{end}}}

//{{$Contract}}Builder gsc自动生成
type {{$Contract}}Builder struct {
    lsbuilder func(service yfdocker.Service) (I{{$Contract}},error)
}

// New{{$Contract}}Builder gsc自动生成
func New{{$Contract}}Builder(lsbuilder func(service yfdocker.Service)(I{{$Contract}},error)) yfdocker.TypeBuilder {
    return &{{$Contract}}Builder{
        lsbuilder:lsbuilder,
    }
}

// String gsc自动生成
func (builder *{{$Contract}}Builder) String() string {
    return "{{.Path}}"
}

// NewService gsc自动生成
func (builder *{{$Contract}}Builder) NewService(name string, id yfdocker.ID, context interface{}) (yfdocker.Service,error) {
    c := &{{$Contract}}Service{
        id:id,
        name:name,
        typename:builder.String(),
        context:context,
        timeout:yfconfig.Seconds(fmt.Sprintf("yfdocker.rpc_timeout.%s",name),5),
    }
    var err error
    c.I{{$Contract}},err = builder.lsbuilder(c)
    return c,err
}

// NewRemoteService gsc自动生成
func (builder *{{$Contract}}Builder) NewRemoteService(remote yfdocker.Remote, name string, lid yfdocker.ID, rid yfdocker.ID, context interface{}) yfdocker.RemoteService {
    return &{{$Contract}}RemoteService{
        name:name,
        remote:remote,
        context: context,
        lid :lid,
        rid :rid,
        typename :builder.String(),
        timeout:yfconfig.Seconds(fmt.Sprintf("yfdocker.rpc_timeout.%s",name),5),
    }
}
{{/**************************************************************************/}}

// {{$Contract}}Service gsc自动生成
type {{$Contract}}Service struct {
    I{{$Contract}}
    id yfdocker.ID
    name string
    typename string
    timeout time.Duration
    context interface{}
}

// String gsc自动生成
func (service *{{$Contract}}Service) String() string {
    return service.name
}

// ID gsc自动生成
func (service *{{$Contract}}Service) ID() yfdocker.ID {
    return service.id
}

// Type gsc自动生成
func (service *{{$Contract}}Service) Type() string {
    return service.typename
}

// Context gsc自动生成
func (service *{{$Contract}}Service) Context() interface{} {
    return service.context
}

// Call gsc自动生成
func (service *{{$Contract}}Service) Call(call *gsnet.Call) (callReturn *gsnet.Return, err error) {
    defer func(){
        if e := recover(); e != nil {
            err = yferrors.New(e.(error))
        }
    }()
    switch call.Method {  {{range .Methods}}
    case {{.ID}}:{{$Name := symbol .Name}}
        if len(call.Params) != {{.InputParams}} {
            err = yferrors.Newf(yfdocker.ErrRPC,"{{$Contract}}::{{$Name}} expect {{.InputParams}} params but got :%d",len(call.Params))
            return
        }

{{range .Params}}        var arg{{.ID}} {{typeName .Type}}
        arg{{.ID}}, err = {{readType .Type}}(bytes.NewBuffer(call.Params[{{.ID}}].Content))
        if err != nil {
            err = yferrors.Newf(err,"read {{$Contract}}::{{$Name}} arg{{.ID}} err")
            return
        }{{"\n"}}{{end}}
{{range .Return}}        var ret{{.ID}} {{typeName .Type}}{{"\n"}}{{end}}
        {{returnargs .}} service.I{{$Contract}}.{{$Name}}{{callargs .Params}}
        if err != nil {
            return
        }
        {{if .Return}}
        callReturn = &gsnet.Return{
            ID : call.ID,
            Service:call.Service,
        }
        {{range .Return}}
        var buff{{.ID}} bytes.Buffer
        err = {{writeType .Type}}(&buff{{.ID}},ret{{.ID}})
        if err != nil {
            return
        }
        callReturn.Params = append(callReturn.Params,&gsnet.Param{Content:buff{{.ID}}.Bytes()})
        {{end}}{{end}}
        return{{end}}
    }
    err = yferrors.Newf(yfdocker.ErrRPC,"unknown {{$Contract}}#%d method",call.Method)
    return
}
{{range .Methods}} {{$Name := symbol .Name}}
// {{$Name}} gsc自动生成
func (service *{{$Contract}}Service){{$Name}}{{params .Params}}{{returnParams .Return}}{
    call := &gsnet.Call{
        Service:uint16(service.id),
        Method:{{.ID}},
    }
{{range .Params}}    var param{{.ID}} bytes.Buffer
    err = {{writeType .Type}}(&param{{.ID}},arg{{.ID}})
    if err != nil {
        return
    }
    call.Params = append(call.Params,&gsnet.Param{Content:param{{.ID}}.Bytes()})
    {{end}}
    {{if .Return}}
    future := make(chan *gsnet.Return,1)
    go func(){
        var callReturn *gsnet.Return
        callReturn,err = service.Call(call)
        if err == nil {
            future <- callReturn
        }
    }()
    select {
        case callreturn := <- future:
            if len(callreturn.Params) != {{.ReturnParams}} {
                err = yferrors.Newf(yfdocker.ErrRPC,"{{$Contract}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callreturn.Params))
                return
            }
            {{range .Return}}
            ret{{.ID}},err = {{readType .Type}}(bytes.NewBuffer(callreturn.Params[{{.ID}}].Content))
            if err != nil {
                err = yferrors.Newf(err,"read {{$Contract}}#{{$Name}} return{{.ID}}")
                return
            }
            {{end}}
        case <- time.After(service.timeout):
            err = yfdocker.ErrTimeout
            return
    }
    {{else}}
    go func(){ service.Call(call) }()
    {{end}}
    return
}
{{end}}

{{/**************************************************************************/}}

// {{$Contract}}RemoteService gsc自动生成
type {{$Contract}}RemoteService struct {
    remote yfdocker.Remote
    rid yfdocker.ID
    lid yfdocker.ID
    name string
    typename string
    context interface{}
    timeout time.Duration
}

// String gsc自动生成
func (service *{{$Contract}}RemoteService) String() string {
    return service.name
}

// ID gsc自动生成
func (service *{{$Contract}}RemoteService) ID() yfdocker.ID {
    return service.lid
}

// RemoteID gsc自动生成
func (service *{{$Contract}}RemoteService) RemoteID() yfdocker.ID {
    return service.rid
}

// Remote gsc自动生成
func (service *{{$Contract}}RemoteService) Remote() yfdocker.Remote {
    return service.remote
}


// Type gsc自动生成
func (service *{{$Contract}}RemoteService) Type() string {
    return service.typename
}

// Context gsc自动生成
func (service *{{$Contract}}RemoteService) Context() interface{} {
    return service.context
}

// Call gsc自动生成
func (service *{{$Contract}}RemoteService) Call(call *gsnet.Call) (callReturn *gsnet.Return, err error) {
    defer func(){
        if e := recover(); e != nil {
            err = yferrors.New(e.(error))
        }
    }()
    switch call.Method {
    {{range .Methods}}
    {{$Name := .Name}}
    case {{.ID}}:
        {{if .Return}}
        var future yfdocker.Future
        future,err = service.remote.Wait(service,call,service.timeout)
        if err != nil {
            err = yferrors.Newf(err,"call {{$Contract}}#{{$Name}} error")
            return
        }
        result := <-future
        if result.Timeout {
            err = yfdocker.ErrTimeout
            return
        }

        callReturn =result.CallReturn

        if len(callReturn.Params) != {{.ReturnParams}} {
            err = yferrors.Newf(yfdocker.ErrRPC,"{{$Contract}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callReturn.Params))
            return
        }

        return
        {{else}}
        err = service.remote.Post(service,call)
        if err != nil {
            err = yferrors.Newf(err,"post {{$Contract}}#{{$Name}} error")
            return
        }
        return
        {{end}}
    {{end}}
    }

    err = yferrors.Newf(yfdocker.ErrRPC,"unknown {{$Contract}}#%d method",call.Method)

    return
}

{{range .Methods}}

{{$Name := symbol .Name}}

// {{$Name}} gsc自动生成
func (service *{{$Contract}}RemoteService){{$Name}}{{params .Params}}{{returnParams .Return}}{
    call := &gsnet.Call{
        Service:uint16(service.rid),
        Method:{{.ID}},
    }

    {{range .Params}}
    var param{{.ID}} bytes.Buffer
    err = {{writeType .Type}}(&param{{.ID}},arg{{.ID}})
    if err != nil {
        return
    }
    call.Params = append(call.Params,&gsnet.Param{Content:param{{.ID}}.Bytes()})
    {{end}}

    {{if .Return}}
    var future yfdocker.Future
    future,err = service.remote.Wait(service,call,service.timeout)
    if err != nil {
        err = yferrors.Newf(err,"call {{$Contract}}#{{$Name}} error")
        return
    }
    result := <-future
    if result.Timeout {
        err = yfdocker.ErrTimeout
        return
    }

    callreturn :=result.CallReturn

    if len(callreturn.Params) != {{.ReturnParams}} {
        err = yferrors.Newf(yfdocker.ErrRPC,"{{$Contract}}#{{$Name}} expect {{.ReturnParams}} return params but got :%d",len(callreturn.Params))
        return
    }

    {{range .Return}}


    ret{{.ID}},err = {{readType .Type}}(bytes.NewBuffer(callreturn.Params[{{.ID}}].Content))
    if err != nil {
        err = yferrors.Newf(err,"read {{$Contract}}#{{$Name}} return{{.ID}}")
        return
    }
    {{end}}
    {{else}}
    err = service.remote.Post(service,call)
    if err != nil {
        err = yferrors.Newf(err,"post {{$Contract}}#{{$Name}} error")
        return
    }
    {{end}}

    return

}
{{end}}

{{end}}
`
